<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../favicon.png" />
		<meta name="viewport" content="width=device-width" />
		<meta http-equiv="content-security-policy" content="">
		<link href="../../_app/immutable/assets/_layout-9c032835.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/_page-1272daef.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/start-3026b7e8.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index-c010bbe4.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/singletons-b0c9f53c.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/preload-helper-28b7b303.js">
		<link rel="modulepreload" href="../../_app/immutable/components/pages/_layout.svelte-6de2596d.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/navigation-fc23c16f.js">
		<link rel="modulepreload" href="../../_app/immutable/modules/pages/_layout.ts-b8ee4d7c.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/_layout-1daba58d.js">
		<link rel="modulepreload" href="../../_app/immutable/components/pages/resources/blog/_slug_/_page.svelte-712e5163.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/profiles-faf00542.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index-6203779a.js">
		<style>
			@import '@fontsource/bebas-neue';
			@import '@fontsource/montserrat';

			@tailwind base;
			@tailwind components;
			@tailwind utilities;

			* {
				margin: 0;
				padding: 0;
			}

			body {
				min-height: 100vh;
				max-width: 100vw;
			}

			.prose p {
				font-family: 'Montserrat', sans-serif !important;
			}
		</style>
	</head>
	<body data-sveltekit-prefetch>
		<div class="app">



<nav class="relative container flex justify-between tracking-[0.065em] mb-12 px-10"><div class="flex items-center justify-between w-full">
		<div class="flex justify-center gap-3"><img class="hidden w-8 aspect-square md:flex" src="/_app/immutable/assets/jc-logo-d894bf84.png" alt="JC Logo">

			<h1 class="pl-4 md:p-0 group block pt-2 font-heading font-extrabold uppercase text-3xl relative"><a href="/" class="no-underline group-hover:underline">JC Robotics </a>
				<span class="absolute w-full h-2 rounded-full scale-0 bg-blue-900 group-hover:scale-1"></span></h1></div>

		
<ul class="hidden md:flex w-1/2 justify-around bg-bangladesh-green text-cornsilk text-xl font-bebas-neue rounded-b-sm"><li class="flex "><a class="relative transistion duration-200 p-6 capitalize after:bg-accent isolate after:z-[-10] | link svelte-zhbz9u" href="/">home</a></li><li class="flex "><a class="relative transistion duration-200 p-6 capitalize after:bg-accent isolate after:z-[-10] | link svelte-zhbz9u" href="/resources/blog">blog</a></li><li class="flex "><a class="relative transistion duration-200 p-6 capitalize after:bg-accent isolate after:z-[-10] | link svelte-zhbz9u" href="/about">about</a></li>
</ul>

		
<div class="relative md:hidden w-6 h-5"><div class="absolute inset-0 flex flex-col justify-between -translate-x-5"><span class="origin-top-left relative transistion ease-out duration-300 w-full h-1/4 bg-white rounded-full false"></span>
		<span class="relative transistion ease-out duration-300 w-full h-1/4 bg-white rounded-full translate-x-1 false"></span>
		<span class="origin-bottom-left relative transistion ease-out duration-300 w-full h-1/4 bg-white rounded-full false"></span></div></div>
		
<ul class="transistion right:0 duration-300 ease-in-out md:hidden flex flex-col absolute w-[80%] mt-50 font-bold bg-primary items-center text-cornsilk text-2xl rounded-md font-bebas-neue top-0  drop-shadow-xl py-6 translate-y-16 left-[50%] -translate-x-[50%] -translate-y-96 z-[10000]"><li class="w-full flex justify-center"><a class="w-full flex justify-center py-3 hover:bg-accent" href="/">home</a>
	</li><li class="w-full flex justify-center"><a class="w-full flex justify-center py-3 hover:bg-accent" href="/resources/blog">blog</a>
	</li><li class="w-full flex justify-center"><a class="w-full flex justify-center py-3 hover:bg-accent" href="/about">about</a>
	</li></ul></div></nav>



<article class="prose lg:prose-xl max-w-full px-8 m-auto my-4 sm:my-16 svelte-5sqr0x"><img class="rounded-md" alt="blog post">
	<h1>Programming Mecannum Wheels</h1>
	<p>Published: 11 December 2022</p>
	<p>By: Orville Daley</p>

	<h2 id="the-physics-of-mecanum">The Physics of Mecanum</h2><p>Mecanum wheels are a special type of wheel that enable maneuverability and holonomic strafing as opposed to traditional wheels. They consist of a series of rubber rollers rotated 45 degrees to either the left or right.</p><p>In a conventional mecanum drivetrain, running the wheels on one diagonal in the opposite direction to those on the other diagonal causes sideways movement. Combinations of these wheel motions allow for vehicle motion in any direction with any vehicle rotation (including no rotation at all).</p><p>A standard mecanum drive configuration possesses 4 mecanum wheels oriented in an “X” shape. This means that the rollers are angled towards the center when looking at it from above. This configuration allows one to add up the force vectors generated by the offset rollers and derive movement in any direction. It is important to note that because of friction, perfect movement isn’t possible in every direction, so a mecanum drivetrain will be able to drive slightly faster forwards/backwards than any other directions. Combining translation and rotation will also result in slower movement.</p><!-- HTML_TAG_START --><!-- ![https://gm0.org/en/latest/_images/mecanum-drive-force-diagram.png](mecannnum) -->
<!-- HTML_TAG_END --><p><!-- HTML_TAG_START --><img src="https://gm0.org/en/latest/_images/mecanum-drive-force-diagram.png" alt="Markdown Monster icon"
style="margin: auto" /><!-- HTML_TAG_END --></p><p>In the image above, vectors 1, 2, 3, and 4 are the force vectors created by the mecanum wheels when the chassis is instructed to drive towards the top of the image. All motors are driving forward. The blue and red lines are their X and Y components, respectively.</p><blockquote><p><strong>Note</strong>
DO NOT HARDCODE THE WHEEL MOVEMENTS, THESE CAN BE PROGRAMMATICALLY COMPUTED</p></blockquote><h2 id="deriving-mecanum-control-equations">Deriving Mecanum Control Equations</h2><h4 id="direction">Direction</h4><p>Joysticks output their x and y coordinates. What you’re after is the angle the joystick is pointed in. To do this, you can calculate the inverse tangent of y/x . You will need to compensate for angles outside of the first quadrant fo the unit circle. Fortunately, most languages have a function called “atan2” instead of the regular “atan” which will fix this problem for you.</p><pre class="python"><code>    x &lt;- gamepad.left_stick_x
    y &lt;- -gamepad.left_stick_y # The y axis of the joystick is flipped with regards to the cartesian plane.

    theta &lt;- ATAN2( y, x )</code></pre><h4 id="magnitude">Magnitude</h4><p>For direction, you used trig to find the angle the joystick was pointed. For magnitude, you need to find the hypotenuse of the same triangle. The simplest way is to use the Pythagorean theorem: a^2+b^2=c^2. By taking the square root of the joystick’s x coordinate squared plus the joystick’s y coordinate squared, you get the length of the hypotenuse.</p><p>Another thing to be careful of is the area in which the joystick can move. We’re assuming the joystick can move in a circular-shaped area, where the maximum hypotenuse (or magnitude) is 1. If the joystick moves around in a square-shaped area, however, the maximum hypotenuse is 1.414. In that case, you would need to make sure any magnitude value greater than 1 is scaled down to 1.</p><h4 id="adding-turn">Adding Turn</h4><p>Most of the work has been done at this point, everything just needs to be put together and a few tweaks need to be made. The code you write should use the joystick x and y to obtain an angle, and the length of the hypotenuse of the triangle that the x and y coordinates make (the magnitude).</p><p>The front-right and back-left wheel should be set to sin(angle−1/4π) * magnitude. The front-left and back-right wheel should be set to sin(angle+1/4π) * magnitude.</p><p>Now the robot has the ability to move laterally in any direction—almost. For most robots, in order to work right, the 2 wheels on one side of the robot need to be inverted because they face the opposite direction. This can be done in a number of ways. For example, if the front-left wheel needed to be inverted, it could instead be set to −sin(angle+1/4π) * magnitude.</p><p>Finally, the robot can move laterally. But there’s one more step: turning. Fortunately, the robot can be easily programmed to turn, even at the same time as it’s driving. We will use a second joystick for this purpose, using horizontal movement to turn the robot (the x-axis). The range of turn values, hence the range of joystick x-axis feedback, should be between [−1, 1]. In the code, the Talon motor controller for each wheel can simply be set to this turn value, no inverting required, and the robot can be turned. But you want to be able to strafe and turn simultaneously, so there’s a bit more work.</p><p>The turn value for each wheel should be added to the lateral movement value for each wheel. It’s actually pretty simple. For example, now our inverted front-left wheel would be set to −sin(angle+1/4π) * magnitude + turn. If you simply add the turn value to the lateral movement value, each wheel will work fine. There’s only one problem: the maximum value a motor controller will take is 1 (or −1, in the negative direction). Anything larger will just be scaled down to 1, creating distortion in our results. So, now that we’ve added up the lateral movement and turn for each wheel, if any are greater than 1, or less than −1, they all need to be scaled by the same factor so that the largest one is one. This factor is easy to obtain: it is the absolute value of the largest (or least, if on the negative side) value. Now the value for each wheel just has to be divided by this factor, and the drive will work.</p><h2 id="the-pseudocode">The Pseudocode</h2><pre class="python"><code>START
    x &lt;- gamepad.left_stick_x
    y &lt;- -gamepad.left_stick_y # The y axis of the joystick is flipped with regards to the cartesian plane.

    turn &lt;- gamepad.right_stick_x

    theta &lt;- ATAN2( x, y ) - PI/4 # Get the angle of the polar coordinates for (x,y). Translate -45 degrees
    power &lt;- square root of (x^2 + y^2) # Get the length of the hypotenuse
    
    set leftFront to power * COS(theta) + turn
    set rightFront to power * SIN(theta) - turn
    set leftBack to power * SIN(theta) + turn
    set rightBack to power * COS(theta) - turn


STOP.</code></pre><h3 id="citations-and-additional-resources">Citations and Additional Resources</h3><pre class=""><code>https://www.youtube.com/watch?v=gnSW2QpkGXQ
https://www.youtube.com/watch?v=Xrc0l4TDnyw
https://www.youtube.com/watch?v=Ne09Y72zW_Y
https://seamonsters-2605.github.io/archive/mecanum/
https://ftcforum.usfirst.org/forum/ftc-technology/android-studio/6361-mecanum-wheels-drive-code-example
https://www.tutorialspoint.com/java/number_atan2.htm
http://thinktank.wpi.edu/resources/346/ControllingMecanumDrive.pdf</code></pre>
</article>


		<script type="module" data-sveltekit-hydrate="177eolo">
			import { start } from "../../_app/immutable/start-3026b7e8.js";

			start({
				env: {},
				hydrate: {
					status: 200,
					error: null,
					node_ids: [0, 8],
					params: {slug:"programming-mecannum-wheels"},
					route: {"id":"/resources/blog/[slug]"},
					data: [null,{type:"data",data:{metadata:{authorId:"orville-daley",slug:"programming-mecannum-wheels",tags:["programming","robot","drivetrain","chassis"],title:"Programming Mecannum Wheels",imageUrl:"mecannum",datePublished:"11 December 2022",readTime:"5"},content:"## The Physics of Mecanum\nMecanum wheels are a special type of wheel that enable maneuverability and holonomic strafing as opposed to traditional wheels. They consist of a series of rubber rollers rotated 45 degrees to either the left or right.\n\nIn a conventional mecanum drivetrain, running the wheels on one diagonal in the opposite direction to those on the other diagonal causes sideways movement. Combinations of these wheel motions allow for vehicle motion in any direction with any vehicle rotation (including no rotation at all).\n\nA standard mecanum drive configuration possesses 4 mecanum wheels oriented in an “X” shape. This means that the rollers are angled towards the center when looking at it from above. This configuration allows one to add up the force vectors generated by the offset rollers and derive movement in any direction. It is important to note that because of friction, perfect movement isn’t possible in every direction, so a mecanum drivetrain will be able to drive slightly faster forwards\u002Fbackwards than any other directions. Combining translation and rotation will also result in slower movement.\n\n\u003C!-- ![https:\u002F\u002Fgm0.org\u002Fen\u002Flatest\u002F_images\u002Fmecanum-drive-force-diagram.png](mecannnum) --\u003E\n\u003Cimg src=\"https:\u002F\u002Fgm0.org\u002Fen\u002Flatest\u002F_images\u002Fmecanum-drive-force-diagram.png\" alt=\"Markdown Monster icon\"\nstyle=\"margin: auto\" \u002F\u003E\n\nIn the image above, vectors 1, 2, 3, and 4 are the force vectors created by the mecanum wheels when the chassis is instructed to drive towards the top of the image. All motors are driving forward. The blue and red lines are their X and Y components, respectively.\n\n\u003E **Note**\n\u003E DO NOT HARDCODE THE WHEEL MOVEMENTS, THESE CAN BE PROGRAMMATICALLY COMPUTED\n\n## Deriving Mecanum Control Equations\n\n#### Direction\nJoysticks output their x and y coordinates. What you’re after is the angle the joystick is pointed in. To do this, you can calculate the inverse tangent of y\u002Fx . You will need to compensate for angles outside of the first quadrant fo the unit circle. Fortunately, most languages have a function called “atan2” instead of the regular “atan” which will fix this problem for you.\n\n```python\n\tx \u003C- gamepad.left_stick_x\n\ty \u003C- -gamepad.left_stick_y # The y axis of the joystick is flipped with regards to the cartesian plane.\n\n\ttheta \u003C- ATAN2( y, x )\n```\n#### Magnitude\nFor direction, you used trig to find the angle the joystick was pointed. For magnitude, you need to find the hypotenuse of the same triangle. The simplest way is to use the Pythagorean theorem: a^2+b^2=c^2. By taking the square root of the joystick’s x coordinate squared plus the joystick’s y coordinate squared, you get the length of the hypotenuse.\n\nAnother thing to be careful of is the area in which the joystick can move. We’re assuming the joystick can move in a circular-shaped area, where the maximum hypotenuse (or magnitude) is 1. If the joystick moves around in a square-shaped area, however, the maximum hypotenuse is 1.414. In that case, you would need to make sure any magnitude value greater than 1 is scaled down to 1.\n\n#### Adding Turn\nMost of the work has been done at this point, everything just needs to be put together and a few tweaks need to be made. The code you write should use the joystick x and y to obtain an angle, and the length of the hypotenuse of the triangle that the x and y coordinates make (the magnitude).\n\nThe front-right and back-left wheel should be set to sin(angle−1\u002F4π) * magnitude. The front-left and back-right wheel should be set to sin(angle+1\u002F4π) * magnitude.\n\nNow the robot has the ability to move laterally in any direction—almost. For most robots, in order to work right, the 2 wheels on one side of the robot need to be inverted because they face the opposite direction. This can be done in a number of ways. For example, if the front-left wheel needed to be inverted, it could instead be set to −sin(angle+1\u002F4π) * magnitude.\n\nFinally, the robot can move laterally. But there’s one more step: turning. Fortunately, the robot can be easily programmed to turn, even at the same time as it’s driving. We will use a second joystick for this purpose, using horizontal movement to turn the robot (the x-axis). The range of turn values, hence the range of joystick x-axis feedback, should be between [−1, 1]. In the code, the Talon motor controller for each wheel can simply be set to this turn value, no inverting required, and the robot can be turned. But you want to be able to strafe and turn simultaneously, so there’s a bit more work.\n\nThe turn value for each wheel should be added to the lateral movement value for each wheel. It’s actually pretty simple. For example, now our inverted front-left wheel would be set to −sin(angle+1\u002F4π) * magnitude + turn. If you simply add the turn value to the lateral movement value, each wheel will work fine. There’s only one problem: the maximum value a motor controller will take is 1 (or −1, in the negative direction). Anything larger will just be scaled down to 1, creating distortion in our results. So, now that we’ve added up the lateral movement and turn for each wheel, if any are greater than 1, or less than −1, they all need to be scaled by the same factor so that the largest one is one. This factor is easy to obtain: it is the absolute value of the largest (or least, if on the negative side) value. Now the value for each wheel just has to be divided by this factor, and the drive will work.\n\n## The Pseudocode\n``` python\nSTART\n\tx \u003C- gamepad.left_stick_x\n\ty \u003C- -gamepad.left_stick_y # The y axis of the joystick is flipped with regards to the cartesian plane.\n\n\tturn \u003C- gamepad.right_stick_x\n\n\ttheta \u003C- ATAN2( x, y ) - PI\u002F4 # Get the angle of the polar coordinates for (x,y). Translate -45 degrees\n\tpower \u003C- square root of (x^2 + y^2) # Get the length of the hypotenuse\n\t\n\tset leftFront to power * COS(theta) + turn\n\tset rightFront to power * SIN(theta) - turn\n\tset leftBack to power * SIN(theta) + turn\n\tset rightBack to power * COS(theta) - turn\n\n\nSTOP.\n```\n\n### Citations and Additional Resources\n\n```\nhttps:\u002F\u002Fwww.youtube.com\u002Fwatch?v=gnSW2QpkGXQ\nhttps:\u002F\u002Fwww.youtube.com\u002Fwatch?v=Xrc0l4TDnyw\nhttps:\u002F\u002Fwww.youtube.com\u002Fwatch?v=Ne09Y72zW_Y\nhttps:\u002F\u002Fseamonsters-2605.github.io\u002Farchive\u002Fmecanum\u002F\nhttps:\u002F\u002Fftcforum.usfirst.org\u002Fforum\u002Fftc-technology\u002Fandroid-studio\u002F6361-mecanum-wheels-drive-code-example\nhttps:\u002F\u002Fwww.tutorialspoint.com\u002Fjava\u002Fnumber_atan2.htm\nhttp:\u002F\u002Fthinktank.wpi.edu\u002Fresources\u002F346\u002FControllingMecanumDrive.pdf\n```\n"},uses:{params:["slug"]}}],
					form: null
				},
				paths: {"base":"","assets":""},
				target: document.querySelector('[data-sveltekit-hydrate="177eolo"]').parentNode,
				trailing_slash: "never"
			});
		</script>
	</div>
	</body>
</html>
