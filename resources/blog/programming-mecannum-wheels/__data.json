{"type":"data","nodes":[null,{"type":"data","data":[{"metadata":1,"content":13},{"authorId":2,"slug":3,"tags":4,"title":9,"imageUrl":10,"datePublished":11,"readTime":12},"orville-daley","programming-mecannum-wheels",[5,6,7,8],"programming","robot","drivetrain","chassis","Programming Mecannum Wheels","mecannum","11 December 2022","5","## The Physics of Mecanum\nMecanum wheels are a special type of wheel that enable maneuverability and holonomic strafing as opposed to traditional wheels. They consist of a series of rubber rollers rotated 45 degrees to either the left or right.\n\nIn a conventional mecanum drivetrain, running the wheels on one diagonal in the opposite direction to those on the other diagonal causes sideways movement. Combinations of these wheel motions allow for vehicle motion in any direction with any vehicle rotation (including no rotation at all).\n\nA standard mecanum drive configuration possesses 4 mecanum wheels oriented in an “X” shape. This means that the rollers are angled towards the center when looking at it from above. This configuration allows one to add up the force vectors generated by the offset rollers and derive movement in any direction. It is important to note that because of friction, perfect movement isn’t possible in every direction, so a mecanum drivetrain will be able to drive slightly faster forwards\u002Fbackwards than any other directions. Combining translation and rotation will also result in slower movement.\n\n\u003C!-- ![https:\u002F\u002Fgm0.org\u002Fen\u002Flatest\u002F_images\u002Fmecanum-drive-force-diagram.png](mecannnum) --\u003E\n\u003Cimg src=\"https:\u002F\u002Fgm0.org\u002Fen\u002Flatest\u002F_images\u002Fmecanum-drive-force-diagram.png\" alt=\"Markdown Monster icon\"\nstyle=\"margin: auto\" \u002F\u003E\n\nIn the image above, vectors 1, 2, 3, and 4 are the force vectors created by the mecanum wheels when the chassis is instructed to drive towards the top of the image. All motors are driving forward. The blue and red lines are their X and Y components, respectively.\n\n\u003E **Note**\n\u003E DO NOT HARDCODE THE WHEEL MOVEMENTS, THESE CAN BE PROGRAMMATICALLY COMPUTED\n\n## Deriving Mecanum Control Equations\n\n#### Direction\nJoysticks output their x and y coordinates. What you’re after is the angle the joystick is pointed in. To do this, you can calculate the inverse tangent of y\u002Fx . You will need to compensate for angles outside of the first quadrant fo the unit circle. Fortunately, most languages have a function called “atan2” instead of the regular “atan” which will fix this problem for you.\n\n```python\n\tx \u003C- gamepad.left_stick_x\n\ty \u003C- -gamepad.left_stick_y # The y axis of the joystick is flipped with regards to the cartesian plane.\n\n\ttheta \u003C- ATAN2( y, x )\n```\n#### Magnitude\nFor direction, you used trig to find the angle the joystick was pointed. For magnitude, you need to find the hypotenuse of the same triangle. The simplest way is to use the Pythagorean theorem: a^2+b^2=c^2. By taking the square root of the joystick’s x coordinate squared plus the joystick’s y coordinate squared, you get the length of the hypotenuse.\n\nAnother thing to be careful of is the area in which the joystick can move. We’re assuming the joystick can move in a circular-shaped area, where the maximum hypotenuse (or magnitude) is 1. If the joystick moves around in a square-shaped area, however, the maximum hypotenuse is 1.414. In that case, you would need to make sure any magnitude value greater than 1 is scaled down to 1.\n\n#### Adding Turn\nMost of the work has been done at this point, everything just needs to be put together and a few tweaks need to be made. The code you write should use the joystick x and y to obtain an angle, and the length of the hypotenuse of the triangle that the x and y coordinates make (the magnitude).\n\nThe front-right and back-left wheel should be set to sin(angle−1\u002F4π) * magnitude. The front-left and back-right wheel should be set to sin(angle+1\u002F4π) * magnitude.\n\nNow the robot has the ability to move laterally in any direction—almost. For most robots, in order to work right, the 2 wheels on one side of the robot need to be inverted because they face the opposite direction. This can be done in a number of ways. For example, if the front-left wheel needed to be inverted, it could instead be set to −sin(angle+1\u002F4π) * magnitude.\n\nFinally, the robot can move laterally. But there’s one more step: turning. Fortunately, the robot can be easily programmed to turn, even at the same time as it’s driving. We will use a second joystick for this purpose, using horizontal movement to turn the robot (the x-axis). The range of turn values, hence the range of joystick x-axis feedback, should be between [−1, 1]. In the code, the Talon motor controller for each wheel can simply be set to this turn value, no inverting required, and the robot can be turned. But you want to be able to strafe and turn simultaneously, so there’s a bit more work.\n\nThe turn value for each wheel should be added to the lateral movement value for each wheel. It’s actually pretty simple. For example, now our inverted front-left wheel would be set to −sin(angle+1\u002F4π) * magnitude + turn. If you simply add the turn value to the lateral movement value, each wheel will work fine. There’s only one problem: the maximum value a motor controller will take is 1 (or −1, in the negative direction). Anything larger will just be scaled down to 1, creating distortion in our results. So, now that we’ve added up the lateral movement and turn for each wheel, if any are greater than 1, or less than −1, they all need to be scaled by the same factor so that the largest one is one. This factor is easy to obtain: it is the absolute value of the largest (or least, if on the negative side) value. Now the value for each wheel just has to be divided by this factor, and the drive will work.\n\n## The Pseudocode\n``` python\nSTART\n\tx \u003C- gamepad.left_stick_x\n\ty \u003C- -gamepad.left_stick_y # The y axis of the joystick is flipped with regards to the cartesian plane.\n\n\tturn \u003C- gamepad.right_stick_x\n\n\ttheta \u003C- ATAN2( x, y ) - PI\u002F4 # Get the angle of the polar coordinates for (x,y). Translate -45 degrees\n\tpower \u003C- square root of (x^2 + y^2) # Get the length of the hypotenuse\n\t\n\tset leftFront to power * COS(theta) + turn\n\tset rightFront to power * SIN(theta) - turn\n\tset leftBack to power * SIN(theta) + turn\n\tset rightBack to power * COS(theta) - turn\n\n\nSTOP.\n```\n\n### Citations and Additional Resources\n\n```\nhttps:\u002F\u002Fwww.youtube.com\u002Fwatch?v=gnSW2QpkGXQ\nhttps:\u002F\u002Fwww.youtube.com\u002Fwatch?v=Xrc0l4TDnyw\nhttps:\u002F\u002Fwww.youtube.com\u002Fwatch?v=Ne09Y72zW_Y\nhttps:\u002F\u002Fseamonsters-2605.github.io\u002Farchive\u002Fmecanum\u002F\nhttps:\u002F\u002Fftcforum.usfirst.org\u002Fforum\u002Fftc-technology\u002Fandroid-studio\u002F6361-mecanum-wheels-drive-code-example\nhttps:\u002F\u002Fwww.tutorialspoint.com\u002Fjava\u002Fnumber_atan2.htm\nhttp:\u002F\u002Fthinktank.wpi.edu\u002Fresources\u002F346\u002FControllingMecanumDrive.pdf\n```\n"],"uses":{"params":["slug"]}}]}